# E0-T0.4: Profiles Table Schema (Extended User Data)

**Epic:** 0 - Project Setup & Infrastructure
**Parent:** E0-T0 (Database Setup)
**Story Points:** 2
**Priority:** P0 (Blocker)
**Assignee:** Backend Developer
**Estimated Time:** 45 minutes
**Dependencies:** E0-T0.3

---

## Objective

Create the `profiles` table schema with extended user information, location data, social links, learning tracks, privacy settings, and statistics. This table contains non-essential user data that is separated from the core `users` table.

---

## Implementation

### File: `drizzle/schema/profiles.ts`

```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  real,
  integer,
  pgEnum,
  foreignKey,
  check,
  index,
} from 'drizzle-orm/pg-core'
import { sql } from 'drizzle-orm'
import { timestamps, softDelete, metadata, PATTERNS } from './utils'
import { users } from './users'

// ============================================================
// ENUMS
// ============================================================

/**
 * User visibility in member directory
 */
export const profileVisibilityEnum = pgEnum('profile_visibility', [
  'public', // Visible to everyone
  'members', // Visible to authenticated members only
  'private', // Hidden from directory
])

/**
 * Availability status for bounties
 */
export const availabilityStatusEnum = pgEnum('availability_status', [
  'available', // Actively looking for work
  'open_to_offers', // Not actively searching but open
  'unavailable', // Not interested in new work
])

/**
 * Learning track selection (3 core tracks)
 */
export const learningTrackEnum = pgEnum('learning_track', [
  'ai', // Artificial Intelligence & Machine Learning
  'crypto', // Blockchain & Cryptocurrency
  'privacy', // Privacy & Security
])

// ============================================================
// TABLE: profiles (Extended User Data)
// ============================================================

/**
 * Extended user profile information separated from core identity table
 *
 * Design Decisions:
 * 1. 1:1 relationship with users table (CASCADE DELETE)
 * 2. All fields nullable (progressive profile completion)
 * 3. Stats tracked for directory sorting/filtering
 * 4. Social links stored as separate fields (not JSONB)
 * 5. Learning tracks as array for multi-selection
 * 6. Location data separated (city, country, countryCode)
 */
export const profiles = pgTable(
  'profiles',
  {
    // Primary Key
    id: uuid('id')
      .primaryKey()
      .default(sql`gen_random_uuid()`),

    // Foreign Key to users (1:1)
    userId: uuid('user_id').unique().notNull(),

    // Location
    city: varchar('city', { length: 100 }),
    country: varchar('country', { length: 100 }),
    countryCode: varchar('country_code', { length: 2 }), // ISO 3166-1 alpha-2

    // Social Links
    githubUrl: varchar('github_url', { length: 500 }),
    twitterUrl: varchar('twitter_url', { length: 500 }),
    linkedinUrl: varchar('linkedin_url', { length: 500 }),
    telegramHandle: varchar('telegram_handle', { length: 100 }),

    // Learning & Skills (3 core tracks: AI, Crypto, Privacy)
    learningTracks: learningTrackEnum('learning_tracks').array(),

    // Privacy Settings
    profileVisibility: profileVisibilityEnum('profile_visibility').default('public').notNull(),

    availabilityStatus: availabilityStatusEnum('availability_status')
      .default('available')
      .notNull(),

    // Statistics (Denormalized for Performance)
    completedBounties: integer('completed_bounties').default(0).notNull(),

    totalEarningsUsd: real('total_earnings_usd').default(0).notNull(),

    profileViews: integer('profile_views').default(0).notNull(),

    // Timestamps & Audit
    ...timestamps,
    ...softDelete,

    // Metadata
    ...metadata, // Feature flags, extended preferences, etc.
  },
  (table) => ({
    // Foreign Key
    userFk: foreignKey({
      columns: [table.userId],
      foreignColumns: [users.id],
      name: 'profiles_user_fk',
    }).onDelete('cascade'),

    // Constraints
    countryCodeFormatCheck: check(
      'country_code_format',
      sql`${table.countryCode} IS NULL OR ${table.countryCode} ~* ${PATTERNS.COUNTRY_CODE}`,
    ),

    completedBountiesPositiveCheck: check(
      'completed_bounties_positive',
      sql`${table.completedBounties} >= 0`,
    ),

    totalEarningsPositiveCheck: check(
      'total_earnings_positive',
      sql`${table.totalEarningsUsd} >= 0`,
    ),

    profileViewsPositiveCheck: check('profile_views_positive', sql`${table.profileViews} >= 0`),

    // Indexes
    userIdIdx: index('idx_profiles_user_id').on(table.userId),
    countryCodeIdx: index('idx_profiles_country_code').on(table.countryCode),

    // Composite index for directory filtering
    visibilityAvailabilityIdx: index('idx_profiles_visibility_availability').on(
      table.profileVisibility,
      table.availabilityStatus,
    ),

    // Partial index for active profiles only
    deletedAtIdx: index('idx_profiles_deleted_at')
      .on(table.deletedAt)
      .where(sql`${table.deletedAt} IS NULL`),

    // Stats indexes for sorting
    completedBountiesIdx: index('idx_profiles_completed_bounties').on(table.completedBounties),
    totalEarningsIdx: index('idx_profiles_total_earnings').on(table.totalEarningsUsd),
  }),
)

// ============================================================
// TYPESCRIPT TYPES
// ============================================================

/**
 * Profile type (for SELECT queries)
 */
export type Profile = typeof profiles.$inferSelect

/**
 * New profile type (for INSERT queries)
 */
export type NewProfile = typeof profiles.$inferInsert
```

---

## Key Design Decisions

### 1. 1:1 Relationship with Users

- Each user has exactly one profile
- CASCADE DELETE: When user deleted, profile deleted automatically
- userId is UNIQUE and NOT NULL

### 2. Progressive Profile Completion

- All fields nullable except userId, visibility, and stats
- Users can complete profile over time
- Defaults set for privacy settings and stats

### 3. Denormalized Statistics

- `completedBounties`, `totalEarningsUsd`, `profileViews` cached for performance
- Updated by application logic (not triggers)
- Allows fast sorting/filtering in directory without complex JOINs

### 4. Learning Tracks (3 Core Tracks)

- **AI**: Artificial Intelligence & Machine Learning
- **Crypto**: Blockchain & Cryptocurrency
- **Privacy**: Privacy & Security
- Uses PostgreSQL array type for multi-selection
- Can query with ANY/ALL operators

### 5. Separate Social Link Fields

- Individual fields instead of JSONB for type safety
- Easier to validate and query
- Clear schema for API consumers

### 6. Location Data

- City and country as free text (user-entered)
- countryCode as ISO 3166-1 alpha-2 for filtering
- CHECK constraint ensures proper country code format

---

## Testing

Create test file: `scripts/test-profiles-schema.ts`

```typescript
import { db } from '../src/lib/db'
import { users, profiles } from '../src/lib/db/schema'
import { sql } from 'drizzle-orm'

async function testProfilesSchema() {
  console.log('ðŸ§ª Testing profiles schema...\n')

  // Test 1: Create user and profile
  const [user] = await db
    .insert(users)
    .values({
      privyDid: 'did:privy:test_profile_user',
      email: 'profile@example.com',
      username: 'profiletest',
      displayName: 'Profile Test User',
      primaryAuthMethod: 'email',
    })
    .returning()

  console.log('âœ… User created:', user.id)

  const [profile] = await db
    .insert(profiles)
    .values({
      userId: user.id,
      city: 'Buenos Aires',
      country: 'Argentina',
      countryCode: 'AR',
      githubUrl: 'https://github.com/profiletest',
      learningTracks: ['ai', 'crypto'],
      profileVisibility: 'public',
      availabilityStatus: 'available',
    })
    .returning()

  console.log('âœ… Profile created:', profile.id)

  // Test 2: Update stats
  const [updatedProfile] = await db
    .update(profiles)
    .set({
      completedBounties: 5,
      totalEarningsUsd: 1250.5,
      profileViews: 42,
    })
    .where(sql`id = ${profile.id}`)
    .returning()

  console.log('âœ… Stats updated:', {
    bounties: updatedProfile.completedBounties,
    earnings: updatedProfile.totalEarningsUsd,
    views: updatedProfile.profileViews,
  })

  // Test 3: Query profiles with filters
  const publicProfiles = await db
    .select()
    .from(profiles)
    .where(sql`profile_visibility = 'public' AND deleted_at IS NULL`)

  console.log(`âœ… Public profiles found: ${publicProfiles.length}`)

  // Test 4: Test CASCADE DELETE
  await db.delete(users).where(sql`id = ${user.id}`)

  const remainingProfiles = await db
    .select()
    .from(profiles)
    .where(sql`user_id = ${user.id}`)

  console.log(`âœ… Cascade delete works: ${remainingProfiles.length === 0 ? 'YES' : 'NO'}`)

  // Cleanup (should be auto-deleted via cascade, but just in case)
  await db.delete(profiles).where(sql`user_id = ${user.id}`)
  await db.delete(users).where(sql`privy_did LIKE 'did:privy:test_profile%'`)

  console.log('\nðŸŽ‰ Profiles schema tests passed!')
}

testProfilesSchema().catch(console.error)
```

Run test:

```bash
bun run scripts/test-profiles-schema.ts
```

---

## Acceptance Criteria

- [ ] `drizzle/schema/profiles.ts` created with complete schema
- [ ] All 3 enums defined (profile_visibility, availability_status, learning_track)
- [ ] Learning track enum has exactly 3 values: 'ai', 'crypto', 'privacy'
- [ ] 1:1 foreign key to users with CASCADE DELETE
- [ ] Location fields (city, country, countryCode) with CHECK constraint
- [ ] Social link fields (github, twitter, linkedin, telegram)
- [ ] Learning tracks as PostgreSQL array
- [ ] Denormalized stats (completedBounties, totalEarningsUsd, profileViews)
- [ ] CHECK constraints for positive stats values
- [ ] All 6 indexes created (including composite and partial)
- [ ] TypeScript types exported (Profile, NewProfile)
- [ ] Test script passes all test cases including CASCADE DELETE

---

## Files Created

- `drizzle/schema/profiles.ts`
- `scripts/test-profiles-schema.ts`

---

## Next Ticket

**E0-T0.5:** Create Applications and Invitations Tables Schema

---

## Notes

- Profile creation should happen automatically after user signup
- Stats updated by application logic (not database triggers)
- CASCADE DELETE ensures orphaned profiles are never created
- Learning tracks limited to 3 core areas: AI, Crypto, Privacy
- Country code validation ensures consistent filtering/grouping

---

**Status:** âœ… Ready for Implementation
**Blocking:** E0-T0.5
**Estimated Completion:** 45 minutes
