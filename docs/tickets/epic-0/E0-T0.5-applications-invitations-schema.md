# E0-T0.5: Applications and Invitations Tables Schema

**Epic:** 0 - Project Setup & Infrastructure
**Parent:** E0-T0 (Database Setup)
**Story Points:** 3
**Priority:** P0 (Blocker)
**Assignee:** Backend Developer
**Estimated Time:** 60 minutes
**Dependencies:** E0-T0.3

---

## Objective

Create the `applications` and `invitations` tables to support the gated onboarding system. Applications track user signup requests pending admin review. Invitations track referral codes with expiration and redemption status.

---

## Implementation

### File: `drizzle/schema/applications.ts`

```typescript
import {
  pgTable,
  uuid,
  varchar,
  text,
  timestamp,
  pgEnum,
  foreignKey,
  index,
} from 'drizzle-orm/pg-core'
import { sql } from 'drizzle-orm'
import { timestamps, metadata } from './utils'
import { users } from './users'

// ============================================================
// ENUMS
// ============================================================

/**
 * Application review status
 */
export const applicationStatusEnum = pgEnum('application_status', [
  'pending', // Awaiting admin review
  'approved', // Approved by admin (user becomes active)
  'rejected', // Rejected by admin
])

// ============================================================
// TABLE: applications (Onboarding Queue)
// ============================================================

/**
 * Tracks user signup applications pending admin review
 *
 * Design Decisions:
 * 1. Foreign key to users (SET NULL on user delete for audit trail)
 * 2. Tracks reviewer and review timestamp
 * 3. No soft delete (permanent audit record)
 * 4. Indexes for admin dashboard filtering
 */
export const applications = pgTable(
  'applications',
  {
    // Primary Key
    id: uuid('id')
      .primaryKey()
      .default(sql`gen_random_uuid()`),

    // User (applicant)
    userId: uuid('user_id').unique().notNull(),

    // Application Content
    motivationText: text('motivation_text').notNull(), // Why they want to join

    // Review Status
    status: applicationStatusEnum('status').default('pending').notNull(),

    // Review Tracking
    reviewedByUserId: uuid('reviewed_by_user_id'),
    reviewedAt: timestamp('reviewed_at', { withTimezone: true }),
    reviewNotes: text('review_notes'), // Admin notes on decision

    // Timestamps & Audit
    ...timestamps,

    // Metadata
    ...metadata, // Source tracking, referral context, etc.
  },
  (table) => ({
    // Foreign Keys
    userFk: foreignKey({
      columns: [table.userId],
      foreignColumns: [users.id],
      name: 'applications_user_fk',
    }).onDelete('set null'),

    reviewedByFk: foreignKey({
      columns: [table.reviewedByUserId],
      foreignColumns: [users.id],
      name: 'applications_reviewed_by_fk',
    }).onDelete('set null'),

    // Indexes
    userIdIdx: index('idx_applications_user_id').on(table.userId),
    statusIdx: index('idx_applications_status').on(table.status),
    reviewedByIdx: index('idx_applications_reviewed_by').on(table.reviewedByUserId),
    createdAtIdx: index('idx_applications_created_at').on(table.createdAt),

    // Composite index for admin dashboard (filter pending + sort by date)
    statusCreatedIdx: index('idx_applications_status_created').on(table.status, table.createdAt),
  }),
)

// ============================================================
// TYPESCRIPT TYPES
// ============================================================

/**
 * Application type (for SELECT queries)
 */
export type Application = typeof applications.$inferSelect

/**
 * New application type (for INSERT queries)
 */
export type NewApplication = typeof applications.$inferInsert
```

---

### File: `drizzle/schema/invitations.ts`

```typescript
import {
  pgTable,
  uuid,
  varchar,
  timestamp,
  pgEnum,
  foreignKey,
  index,
  check,
} from 'drizzle-orm/pg-core'
import { sql } from 'drizzle-orm'
import { timestamps, metadata, PATTERNS } from './utils'
import { users } from './users'

// ============================================================
// TABLE: invitations (Referral System)
// ============================================================

/**
 * Tracks invitation codes with expiration and redemption status
 *
 * Design Decisions:
 * 1. Generated status column (computed from redeemed_at and expires_at)
 * 2. No soft delete (permanent audit record)
 * 3. Unique invite code for sharing
 * 4. Foreign key to inviter (CASCADE DELETE removes orphaned invites)
 * 5. Tracks redeemer for viral growth metrics
 */
export const invitations = pgTable(
  'invitations',
  {
    // Primary Key
    id: uuid('id')
      .primaryKey()
      .default(sql`gen_random_uuid()`),

    // Inviter (who created the invite)
    inviterUserId: uuid('inviter_user_id').notNull(),

    // Redeemer (who used the invite)
    redeemerUserId: uuid('redeemer_user_id'),

    // Invitation Details
    inviteCode: varchar('invite_code', { length: 32 }).unique().notNull(), // URL-safe random string

    // Status Tracking
    redeemedAt: timestamp('redeemed_at', { withTimezone: true }),
    expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),

    // Generated Status (computed column)
    // 'pending': Not redeemed and not expired
    // 'redeemed': Has redeemed_at timestamp
    // 'expired': Past expires_at and not redeemed
    status: varchar('status', { length: 20 }).generatedAlwaysAs(
      sql`
          CASE
            WHEN redeemed_at IS NOT NULL THEN 'redeemed'
            WHEN expires_at < NOW() THEN 'expired'
            ELSE 'pending'
          END
        `,
      { mode: 'stored' },
    ),

    // Timestamps & Audit
    ...timestamps,

    // Metadata
    ...metadata, // Campaign tracking, invite source, etc.
  },
  (table) => ({
    // Foreign Keys
    inviterFk: foreignKey({
      columns: [table.inviterUserId],
      foreignColumns: [users.id],
      name: 'invitations_inviter_fk',
    }).onDelete('cascade'),

    redeemerFk: foreignKey({
      columns: [table.redeemerUserId],
      foreignColumns: [users.id],
      name: 'invitations_redeemer_fk',
    }).onDelete('set null'),

    // Constraints
    inviteCodeFormatCheck: check(
      'invite_code_format',
      sql`${table.inviteCode} ~* ${PATTERNS.INVITE_CODE}`,
    ),

    // Indexes
    inviterUserIdIdx: index('idx_invitations_inviter').on(table.inviterUserId),
    redeemerUserIdIdx: index('idx_invitations_redeemer').on(table.redeemerUserId),
    inviteCodeIdx: index('idx_invitations_code').on(table.inviteCode),

    // Generated status index for filtering
    statusIdx: index('idx_invitations_status').on(table.status),

    // Partial index for active invites only
    pendingInvitesIdx: index('idx_invitations_pending')
      .on(table.inviterUserId, table.status)
      .where(sql`${table.status} = 'pending'`),
  }),
)

// ============================================================
// TYPESCRIPT TYPES
// ============================================================

/**
 * Invitation type (for SELECT queries)
 */
export type Invitation = typeof invitations.$inferSelect

/**
 * New invitation type (for INSERT queries)
 */
export type NewInvitation = typeof invitations.$inferInsert
```

---

### Update: `drizzle/schema/utils.ts`

Add the INVITE_CODE pattern:

```typescript
export const PATTERNS = {
  EMAIL: '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$',
  ETH_ADDRESS: '^0x[a-fA-F0-9]{40}$',
  USERNAME: '^[a-z0-9_]{3,50}$',
  COUNTRY_CODE: '^[A-Z]{2}$',
  INVITE_CODE: '^[A-Za-z0-9_-]{16,32}$', // URL-safe base64-like
}
```

---

## Key Design Decisions

### Applications Table

#### 1. Gated Onboarding Flow

- User signs up â†’ creates application with motivation text
- Admin reviews â†’ approves/rejects with notes
- Approved users get `account_status = 'active'` in users table

#### 2. Permanent Audit Trail

- No soft delete (applications are permanent records)
- SET NULL on user/reviewer delete (preserves application history)
- Tracks who reviewed and when

#### 3. Admin Dashboard Optimizations

- Composite index on (status, created_at) for filtering pending + sorting
- Separate indexes for status, reviewer, and created_at

### Invitations Table

#### 1. Generated Status Column

- PostgreSQL computes status automatically based on timestamps
- `pending`: Not redeemed and not expired
- `redeemed`: Has redeemed_at timestamp
- `expired`: Past expires_at and not redeemed
- No manual status updates needed

#### 2. Viral Growth Tracking

- inviterUserId: Who created the invite
- redeemerUserId: Who used it
- Enables referral analytics and gamification

#### 3. CASCADE DELETE for Inviter

- When user deleted, their invitations are deleted too
- Makes sense: deleted user's invites shouldn't work
- SET NULL for redeemer (preserve history if redeemer deleted)

#### 4. Expiration Handling

- expiresAt timestamp set at creation (e.g., 7 days)
- Generated status column automatically marks expired invites
- Partial index for pending invites improves performance

---

## Testing

Create test file: `scripts/test-applications-invitations-schema.ts`

```typescript
import { db } from '../src/lib/db'
import { users, applications, invitations } from '../src/lib/db/schema'
import { sql } from 'drizzle-orm'

async function testApplicationsInvitationsSchema() {
  console.log('ðŸ§ª Testing applications and invitations schemas...\n')

  // Create test users
  const [applicant] = await db
    .insert(users)
    .values({
      privyDid: 'did:privy:test_applicant',
      email: 'applicant@example.com',
      username: 'applicant',
      displayName: 'Test Applicant',
      primaryAuthMethod: 'email',
      accountStatus: 'pending',
    })
    .returning()

  const [admin] = await db
    .insert(users)
    .values({
      privyDid: 'did:privy:test_admin',
      email: 'admin@example.com',
      username: 'admin',
      displayName: 'Test Admin',
      primaryAuthMethod: 'email',
      role: 'admin',
      accountStatus: 'active',
    })
    .returning()

  console.log('âœ… Test users created')

  // Test 1: Create application
  const [application] = await db
    .insert(applications)
    .values({
      userId: applicant.id,
      motivationText: 'I want to learn blockchain development and contribute to Web3 projects.',
      status: 'pending',
    })
    .returning()

  console.log('âœ… Application created:', application.id)

  // Test 2: Admin reviews application
  const [reviewedApp] = await db
    .update(applications)
    .set({
      status: 'approved',
      reviewedByUserId: admin.id,
      reviewedAt: new Date(),
      reviewNotes: 'Strong motivation, approved!',
    })
    .where(sql`id = ${application.id}`)
    .returning()

  console.log('âœ… Application approved by admin')

  // Test 3: Create invitation
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days from now
  const [invite] = await db
    .insert(invitations)
    .values({
      inviterUserId: admin.id,
      inviteCode: 'TEST_INVITE_CODE_123',
      expiresAt,
    })
    .returning()

  console.log('âœ… Invitation created:', invite.id)
  console.log('   Generated status:', invite.status) // Should be 'pending'

  // Test 4: Redeem invitation
  const [redeemedInvite] = await db
    .update(invitations)
    .set({
      redeemerUserId: applicant.id,
      redeemedAt: new Date(),
    })
    .where(sql`id = ${invite.id}`)
    .returning()

  console.log('âœ… Invitation redeemed')
  console.log('   Updated status:', redeemedInvite.status) // Should be 'redeemed'

  // Test 5: Create expired invitation
  const [expiredInvite] = await db
    .insert(invitations)
    .values({
      inviterUserId: admin.id,
      inviteCode: 'EXPIRED_INVITE_CODE',
      expiresAt: new Date(Date.now() - 1000), // 1 second ago
    })
    .returning()

  console.log('âœ… Expired invitation created')
  console.log('   Generated status:', expiredInvite.status) // Should be 'expired'

  // Test 6: Query pending applications
  const pendingApps = await db
    .select()
    .from(applications)
    .where(sql`status = 'pending'`)

  console.log(`âœ… Pending applications: ${pendingApps.length}`)

  // Cleanup
  await db.delete(applications).where(sql`user_id = ${applicant.id}`)
  await db.delete(invitations).where(sql`inviter_user_id = ${admin.id}`)
  await db.delete(users).where(sql`privy_did LIKE 'did:privy:test_%'`)

  console.log('\nðŸŽ‰ Applications and invitations schemas tests passed!')
}

testApplicationsInvitationsSchema().catch(console.error)
```

Run test:

```bash
bun run scripts/test-applications-invitations-schema.ts
```

---

## Acceptance Criteria

### Applications Table

- [ ] `drizzle/schema/applications.ts` created with complete schema
- [ ] application_status enum defined (pending, approved, rejected)
- [ ] Foreign keys to users (applicant and reviewer) with SET NULL
- [ ] All 5 indexes created (including composite status_created index)
- [ ] No soft delete (permanent audit record)
- [ ] TypeScript types exported (Application, NewApplication)

### Invitations Table

- [ ] `drizzle/schema/invitations.ts` created with complete schema
- [ ] Generated status column (pending, redeemed, expired)
- [ ] Foreign keys to users (inviter CASCADE, redeemer SET NULL)
- [ ] Invite code format CHECK constraint
- [ ] All 5 indexes created (including partial index for pending)
- [ ] TypeScript types exported (Invitation, NewInvitation)

### Testing

- [ ] Test script passes all test cases
- [ ] Generated status column works correctly (pending/redeemed/expired)
- [ ] CASCADE DELETE works for inviter
- [ ] SET NULL works for reviewer and redeemer

---

## Files Created

- `drizzle/schema/applications.ts`
- `drizzle/schema/invitations.ts`
- `scripts/test-applications-invitations-schema.ts`

---

## Next Ticket

**E0-T0.6:** Create Database Client and Schema Index

---

## Notes

- Generated status column eliminates need for manual status updates
- Applications use SET NULL (preserve history even if user deleted)
- Invitations use CASCADE DELETE for inviter (their invites should be removed)
- Composite indexes optimize admin dashboard queries
- Partial index for pending invites improves referral code lookup

---

**Status:** âœ… Ready for Implementation
**Blocking:** E0-T0.6
**Estimated Completion:** 60 minutes
