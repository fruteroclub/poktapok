# E0-T0.3: Users Table Schema (Identity & Auth)

**Epic:** 0 - Project Setup & Infrastructure
**Parent:** E0-T0 (Database Setup)
**Story Points:** 2
**Priority:** P0 (Blocker)
**Assignee:** Backend Developer
**Estimated Time:** 45 minutes
**Dependencies:** E0-T0.2

---

## Objective

Create the `users` table schema with Privy authentication integration, wallet support, and comprehensive constraints.

---

## Implementation

### File: `drizzle/schema/users.ts`

```typescript
import {
  pgTable,
  uuid,
  varchar,
  timestamp,
  pgEnum,
  jsonb,
  foreignKey,
  check,
  index,
} from 'drizzle-orm/pg-core'
import { sql } from 'drizzle-orm'
import { timestamps, softDelete, metadata, PATTERNS } from './utils'

// ============================================================
// ENUMS
// ============================================================

/**
 * User role for access control
 */
export const userRoleEnum = pgEnum('user_role', ['member', 'moderator', 'admin'])

/**
 * Account status for user lifecycle management
 */
export const accountStatusEnum = pgEnum('account_status', [
  'pending', // Applied, waiting for approval
  'active', // Approved and active
  'suspended', // Temporarily disabled
  'banned', // Permanently disabled
])

/**
 * Primary authentication method tracking
 */
export const authMethodEnum = pgEnum('auth_method', [
  'email', // Email magic link
  'wallet', // External wallet (MetaMask, Coinbase, etc.)
  'social', // Social login (Google, GitHub, Discord, etc.)
])

// ============================================================
// TABLE: users (Identity & Authentication)
// ============================================================

/**
 * Core identity table linked to Privy authentication
 *
 * Privy Authentication & Wallet Model:
 * - Email: Always required (collected during onboarding)
 * - External Wallet (ext_wallet): Optional, user's own wallet for auth
 * - Embedded Wallet (app_wallet): Created by Privy after authentication
 * - Auth methods: email, social (Google/GitHub), or wallet
 *
 * Design Decisions:
 * 1. privy_did as source of truth (stable across auth methods)
 * 2. Email always required (NOT NULL)
 * 3. Separate ext_wallet (external) and app_wallet (embedded)
 * 4. Soft deletes for audit trail
 * 5. Separate metadata: privy_metadata (SDK) vs metadata (business logic)
 */
export const users = pgTable(
  'users',
  {
    // Primary Key
    id: uuid('id')
      .primaryKey()
      .default(sql`gen_random_uuid()`),

    // Authentication (Privy Integration)
    privyDid: varchar('privy_did', { length: 255 }).unique().notNull(),

    // Contact & Identity
    email: varchar('email', { length: 255 }).unique().notNull(),

    // Profile Identifiers (Core User Identity)
    username: varchar('username', { length: 50 }).unique().notNull(),
    displayName: varchar('display_name', { length: 100 }).notNull(),
    bio: text('bio'), // Max 280 characters enforced at app level
    avatarUrl: varchar('avatar_url', { length: 500 }),

    // Wallets
    extWallet: varchar('ext_wallet', { length: 42 }), // External wallet (optional)
    appWallet: varchar('app_wallet', { length: 42 }), // Privy embedded wallet (created async)

    // Login Method Tracking
    primaryAuthMethod: authMethodEnum('primary_auth_method').notNull(),

    // Account Management
    role: userRoleEnum('role').default('member').notNull(),

    accountStatus: accountStatusEnum('account_status').default('pending').notNull(),

    // Referral Tracking
    invitedByUserId: uuid('invited_by_user_id'),
    approvedByUserId: uuid('approved_by_user_id'),

    // Timestamps & Audit
    ...timestamps,
    lastLoginAt: timestamp('last_login_at', { withTimezone: true }).defaultNow().notNull(),
    ...softDelete,

    // Metadata (Separated Concerns)
    privyMetadata: jsonb('privy_metadata')
      .default(sql`'{}'::jsonb`)
      .notNull(), // Privy SDK data (wallet timestamps, connection info)
    ...metadata, // Business logic (NFT memberships, feature flags, preferences)
  },
  (table) => ({
    // Foreign Keys (self-referencing for referrals and approvals)
    invitedByFk: foreignKey({
      columns: [table.invitedByUserId],
      foreignColumns: [table.id],
      name: 'users_invited_by_fk',
    }).onDelete('set null'),

    approvedByFk: foreignKey({
      columns: [table.approvedByUserId],
      foreignColumns: [table.id],
      name: 'users_approved_by_fk',
    }).onDelete('set null'),

    // Constraints
    emailFormatCheck: check('email_format', sql`${table.email} ~* ${PATTERNS.EMAIL}`),

    usernameFormatCheck: check('username_format', sql`${table.username} ~* ${PATTERNS.USERNAME}`),

    extWalletFormatCheck: check(
      'ext_wallet_format',
      sql`${table.extWallet} IS NULL OR ${table.extWallet} ~* ${PATTERNS.ETH_ADDRESS}`,
    ),

    appWalletFormatCheck: check(
      'app_wallet_format',
      sql`${table.appWallet} IS NULL OR ${table.appWallet} ~* ${PATTERNS.ETH_ADDRESS}`,
    ),

    // Indexes
    privyDidIdx: index('idx_users_privy_did').on(table.privyDid),
    emailIdx: index('idx_users_email').on(table.email),
    usernameIdx: index('idx_users_username').on(table.username),

    // Partial indexes (only index non-null values)
    extWalletIdx: index('idx_users_ext_wallet')
      .on(table.extWallet)
      .where(sql`${table.extWallet} IS NOT NULL`),

    appWalletIdx: index('idx_users_app_wallet')
      .on(table.appWallet)
      .where(sql`${table.appWallet} IS NOT NULL`),

    accountStatusIdx: index('idx_users_account_status').on(table.accountStatus),
    invitedByIdx: index('idx_users_invited_by').on(table.invitedByUserId),

    // Soft delete partial index (only index active users)
    deletedAtIdx: index('idx_users_deleted_at')
      .on(table.deletedAt)
      .where(sql`${table.deletedAt} IS NULL`),

    primaryAuthIdx: index('idx_users_primary_auth').on(table.primaryAuthMethod),
  }),
)

// ============================================================
// TYPESCRIPT TYPES
// ============================================================

/**
 * User type (for SELECT queries)
 */
export type User = typeof users.$inferSelect

/**
 * New user type (for INSERT queries)
 */
export type NewUser = typeof users.$inferInsert
```

---

## Key Design Decisions

### 1. Privy DID as Source of Truth

- Stable identifier across all auth methods
- Format: `did:privy:abc123`
- Unique and immutable

### 2. Email Always Required

- NOT NULL constraint enforces collection
- Collected during onboarding for all signup methods
- Used for communication and account recovery

### 3. Separate Wallet Fields

- `extWallet`: User's external wallet (MetaMask, Coinbase, etc.)
- `appWallet`: Privy-managed embedded wallet
- Both nullable (users may not have external wallet, embedded wallet created async)

### 4. Key User Identifiers in Users Table

- `username`: Unique identifier for @mentions and profile URLs
- `displayName`: Full name shown in UI
- `bio`: Short user description (max 280 characters)
- `avatarUrl`: Profile image URL
- These are core identity fields, not separated into profiles table

### 5. Dual Metadata Fields

- `privyMetadata`: Privy SDK internals (wallet creation timestamps, connection info)
- `metadata`: Business logic (NFT memberships, feature flags, user preferences)

### 6. Soft Deletes

- `deletedAt` timestamp instead of hard delete
- Preserves data for audit/compliance
- Partial index for performance (only indexes NULL values)

---

## Testing

Create test file: `scripts/test-users-schema.ts`

```typescript
import { db } from '../src/lib/db'
import { users } from '../src/lib/db/schema'

async function testUsersSchema() {
  console.log('ðŸ§ª Testing users schema...\\n')

  // Test 1: Create user with email auth
  const [emailUser] = await db
    .insert(users)
    .values({
      privyDid: 'did:privy:test_email',
      email: 'test@example.com',
      username: 'testuser',
      displayName: 'Test User',
      bio: 'This is a test user account',
      primaryAuthMethod: 'email',
      role: 'member',
      accountStatus: 'active',
    })
    .returning()

  console.log('âœ… Email user created:', emailUser.id)

  // Test 2: Create user with wallet auth
  const [walletUser] = await db
    .insert(users)
    .values({
      privyDid: 'did:privy:test_wallet',
      email: 'wallet@example.com',
      username: 'walletuser',
      displayName: 'Wallet User',
      extWallet: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb5',
      primaryAuthMethod: 'wallet',
      role: 'member',
      accountStatus: 'active',
    })
    .returning()

  console.log('âœ… Wallet user created:', walletUser.id)

  // Test 3: Update app_wallet (simulating Privy async creation)
  const [updatedUser] = await db
    .update(users)
    .set({ appWallet: '0x1234567890123456789012345678901234567890' })
    .where(sql`id = ${emailUser.id}`)
    .returning()

  console.log('âœ… App wallet added:', updatedUser.appWallet)

  // Test 4: Soft delete
  await db
    .update(users)
    .set({ deletedAt: new Date() })
    .where(sql`id = ${emailUser.id}`)

  console.log('âœ… User soft deleted')

  // Test 5: Query active users only
  const activeUsers = await db
    .select()
    .from(users)
    .where(sql`deleted_at IS NULL`)

  console.log(`âœ… Active users found: ${activeUsers.length}`)

  // Cleanup
  await db.delete(users).where(sql`privy_did LIKE 'did:privy:test_%'`)
  console.log('\\nðŸŽ‰ Users schema tests passed!')
}

testUsersSchema().catch(console.error)
```

Run test:

```bash
bun run scripts/test-users-schema.ts
```

---

## Acceptance Criteria

- [ ] `drizzle/schema/users.ts` created with complete schema
- [ ] All 3 enums defined (user_role, account_status, auth_method)
- [ ] Core identity fields added (username, displayName, bio, avatarUrl)
- [ ] Email format CHECK constraint applied
- [ ] Username format CHECK constraint applied
- [ ] Ethereum address format CHECK constraints for both wallet fields
- [ ] Self-referencing foreign keys for invited_by and approved_by
- [ ] All 9 indexes created (including partial indexes)
- [ ] Dual metadata fields (privy_metadata and metadata)
- [ ] Soft delete field (deleted_at)
- [ ] TypeScript types exported (User, NewUser)
- [ ] Test script passes all test cases

---

## Files Created

- `drizzle/schema/users.ts`
- `scripts/test-users-schema.ts`

---

## Next Ticket

**E0-T0.4:** Create Profiles Table Schema

---

## Notes

- This is the foundation table - all other tables reference users
- Email always required (corrected from initial design)
- Core user identifiers (username, displayName, bio, avatarUrl) kept in users table for performance
- Partial indexes improve performance by only indexing relevant rows
- Self-referencing FKs use SET NULL (preserve history if admin/inviter deleted)

---

**Status:** âœ… Ready for Implementation
**Blocking:** E0-T0.4, E0-T0.5, E0-T0.6
**Estimated Completion:** 45 minutes
